:stem: latexmath
:icons: font
:source-highlighter: coderay
:sectnums:
:sectlinks:
:sectnumlevels: 4
:toc: left
:toc-title: 目录
:toclevels: 3

[NOTE]
====
spring-framework.version=5.3.30
====

== 模块概览

=== 核心模块

[plantuml,spring-framework-overview-core.png]
--
@startwbs
+ spring-framework
++ spring-core
+++ spring-jcl
++ spring-aop
+++ spring-beans
+++ spring-core
++ spring-beans
+++ spring-core
++ spring-context
+++ spring-core
+++ spring-aop
+++ spring-beans
+++ spring-expression
+++ spring-tx
++ spring-oxm
+++ spring-core
+++ spring-beans
@endwbs
--

=== 数据模块

[plantuml,spring-framework-overview-dataaccess.png]
--
@startwbs
+ spring-framework
++ spring-tx
+++ spring-core
+++ spring-beans
++ spring-jdbc
+++ spring-core
+++ spring-beans

@endwbs
--

=== web模块

[plantuml,spring-framework-overview-web.png]
--
@startwbs
+ spring-framework
++ spring-web
+++ spring-core
+++ spring-beans
++ spring-webmvc
+++ spring-core
+++ spring-beans
+++ spring-context
+++ spring-aop
+++ spring-expression
+++ spring-web
@endwbs
--

=== 其他模板

[plantuml,spring-framework-overview-other.png]
--
@startwbs
+ spring-framework
++ spring-expression
+++ spring-core
@endwbs
--

== spring-expression

=== Spel

==== 上下文

[plantuml,spring-framework-expression-context.png]
--
@startuml
interface EvaluationContext {
    Object lookupVariable(String name)
    
    List<PropertyAccessor> getPropertyAccessors();
}
class StandardEvaluationContext {

}

EvaluationContext <|.. StandardEvaluationContext
@enduml
--

==== 解析表达式

===== 核心类图

[plantuml,spring-framework-expression-parse.png]
--
@startuml
interface ExpressionParser {
    Expression parseExpression(String expressionString, ParserContext context)
}
class TemplateAwareExpressionParser {
    SpelExpression doParseExpression(String expressionString, ParserContext context)
}
class InternalSpelExpressionParser {

}
class SpelExpressionParser {

}

interface Expression {
    Object getValue();
}
class SpelExpression {
    private SpelNodeImpl ast;
}
class SpelNodeImpl {
    protected SpelNodeImpl[] children;

    Object getValue(ExpressionState expressionState)
    abstract TypedValue getValueInternal(ExpressionState expressionState)
}

ExpressionParser <|.. TemplateAwareExpressionParser
TemplateAwareExpressionParser <|-- InternalSpelExpressionParser
TemplateAwareExpressionParser <|-- SpelExpressionParser
Expression <|.. SpelExpression

SpelExpressionParser .. InternalSpelExpressionParser
SpelExpressionParser .. SpelExpression
SpelExpression --> SpelNodeImpl
@enduml
--

===== 说明

[source,txt]
----
1. SpelExpressionParser使用TemplateAwareExpressionParser.doParseExpression解析表达式，生成SpelExpression对象
2. SpelExpression持有SpelNodeImpl用于表达式取值
----

==== 取值

[plantuml,spring-framework-expression-value.png]
--
@startuml
class SpelNodeImpl {
    protected SpelNodeImpl[] children;

    Object getValue(ExpressionState expressionState)
    abstract TypedValue getValueInternal(ExpressionState expressionState)
}

class CompoundExpression {
}
class VariableReference {
}
class PropertyOrFieldReference {
}

SpelNodeImpl <|-- CompoundExpression
SpelNodeImpl <|-- VariableReference
SpelNodeImpl <|-- PropertyOrFieldReference
@enduml
--

===== 说明

[source,txt]
----
1. SpelNodeImpl有很多实现，其中PropertyOrFieldReference最关键
2. PropertyOrFieldReference可以组合PropertyAccessor使用
----

==== 自定义解析器

[plantuml,spring-framework-expression-propertyaccessor.png]
--
@startuml
interface PropertyAccessor {
    Class<?>[] getSpecificTargetClasses();
    
    TypedValue read(EvaluationContext context, Object target, String name);
}
class ReflectivePropertyAccessor {
}
class JsonPropertyAccessor {
}

PropertyAccessor <|-- ReflectivePropertyAccessor
PropertyAccessor <|-- JsonPropertyAccessor
@enduml
--

===== 说明

[source,txt]
----
1. PropertyAccessor#getSpecificTargetClasses可以指定处理哪些Class
2. ReflectivePropertyAccessor 为默认实现，通过反射取值
3. JsonPropertyAccessor通过ObjectMapper取值，包路径：org.springframework.integration.json
----

== spring-core

=== TypeDescriptor&ResolvableType

==== 基础

[plantuml,java-type.png]
--
@startuml
interface Type {
}
class Class<T> {
}
interface GenericArrayType {
    Type getGenericComponentType();
}
interface ParameterizedType {
    Type[] getActualTypeArguments();
    Type getRawType();
    Type getOwnerType();
}
interface TypeVariable {
    Type[] getBounds();
    D getGenericDeclaration();
    String getName();
    AnnotatedType[] getAnnotatedBounds();
}
interface WildcardType {
    Type[] getUpperBounds();
    Type[] getLowerBounds();
}


Type <|-- GenericArrayType
Type <|-- ParameterizedType
Type <|-- TypeVariable
Type <|-- WildcardType

Type <|.. Class
@enduml
--

==== 类图

[plantuml,spring-framework-core-resolvabletype.png]
--
@startuml
class TypeDescriptor {
    private final Class<?> type;
	private final ResolvableType resolvableType;
	private final AnnotatedElementAdapter annotatedElement;
}
class ResolvableType {
    private final Type type;
    private Class<?> resolved;
}

TypeDescriptor --> ResolvableType
@enduml
--

===== 说明

[source,txt]
----
1. ResolvableType是对Class的封装，支持访问其父类、泛型
2. TypeDescriptor依赖了ResolvableType，多了注解的能力
----
